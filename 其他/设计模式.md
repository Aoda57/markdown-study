# 设计模式

## 观察者/发布订阅者模式

## 工厂模式
任何时候创建对象，但是不想指明具体的class时使用

> 工厂模式的目的是为了创建对象，它通常在类或者类的静态方法中实现，具有以下目标：
1. 当创建相似对象时执行重复操作
2. 当编译时不知道具体类型的情况下，为工厂客户提供一个创建对象的接口
3. 与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。
4. 用工厂的方法来创建对象
> <strong>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</strong>


> 规则：遵循对扩展开放，对修改关闭---开闭原则
> 三种方式分别解决从简单到复杂的产品创建，中会出现不符合该原则时，使用下一种方法
### 简单工厂模式
> 生成该对象的实例，类的实例化。 
> 特点     
> 1. 一般做一种类型的对象的实例化,相当于new 一个class  
> 2. 生成实例  

``` javascript
   function Person(name,age){
       const obj= {
            name,age
       }
       obj.getInfo=function (){
           return `name:${obj.name}  age:${obj.age}`;
       }
       return obj;
   }
```
###  工厂方法模式
> 通过工厂函数，将根据需要创建的实例类型，决定去实例化哪一个类，类的实例化在子类中完成
> 特点     
> 1. 一般做多种种类型的对象的实例化,相当于new 一个class  
> 2. 只做生成实例这一件事  
> 3. 用工厂方法来创建对象
<!-- > 3. 我可以在如果知道类名字情况下，根据这个名字去创建这个类 -->


``` javascript
// 示例一
// 创建一个抽象类：只能被继承，子类通过super(),去创建这个实例
// class User {
//     constructor(name,role){
//         if(new.target){
//             throw "抽象类不允许new"
//         }
//         this.name= name;
//         this.role=role;
//     }
// }
// class UserFactor extend User{
//     constructor(name,age){
//         super(name,age);
//     }
// }

// 示例二
function Factory(role,options){
    if(this[role]){
        return new this[role](options)
    }else{
        return new Factory(options)
    }
}
Factory.prototype= {
    admin:function(options){
        console.log("admin can do edit sql")
    },
    user:function(options){
        console.log("user only use computer")
    }
}
```
### 抽象工厂模式

1. 不能生成实例
2. 一般做产品类簇的创建
``` javascript
   class AbstractorUsrFactory{
       constructor(role){
           switch(role){
               case 'admin':
               return Admin;
                case 'user':
               return User;
                default  :
               return Other;
           }
       }
   }
```
总结
1. 使用者只需要知道特定子类的名称就可以直接生产对应的子类，无需知道具体实现逻辑
2. 实际的创建对象过程在子类中进行
3. 在创建相似子类的时候，执行重复操作（每个子类只做一次的继承）

tips:
1. js的Object就是一个工厂函数，
``` javascript 
 new Object(1) // Number(1)
 new Object([1,2,4]) // [1,2,4]
 new Object("string") // ”string“
 ```


 ##  单例模式

 ``` javascript 
 // 闭包实现单例模式
   class User {
       constructor(name){
           this.name= name
       }
      static getInstance =(function(){
            let instance;
            return function (name){
                if(!instance){
                   instance = new User(name);
                }
                return instance
            }
        
       })()

    //  static getInstance(name) {
    //     if (User.instance === undefined) {
    //          User.instance = new User(name);
    //      }
    //           return User.instance;
    //  }
   }
   // 通过静态方法getInstance 实现class唯一实例化对象
 ```