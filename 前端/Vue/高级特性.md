# Vue的高级特性
## 自定义v-model
> v-model:在表单控件或者组件上创建双向绑定
> 原理: 给组件添加 v-model 属性时，默认会把 value 作为组件的属性，
> 然后把 'input' 值作为给组件绑定事件时的事件名
``` javascript
Vue.component('Parent', {
  template: `
    <Child v-model="data"/>
  `
})
 // 等效于
Vue.component('Parent', {
  template: ` <Child :value="data" @input="data=$event.target.value""/>`
)}

 //在创建类似复选框或者单选框的常见组件时。value、input不是所需的属性和事件，需要自定义
 // Child组件内部实现 + 修改默认的v-model配置
Vue.component('Child', {
  model: {
    prop: 'checked', // 将model重命名为其他名称
    event: 'change' // 将默认事件改为其他事件
  },
  props: {
    checked: Boolean // 设定传入prop的类型
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```
## vm.$nextTick
>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

> 宏任务、微任务、同步任务、异步任务
> macro task 有 setTimeout、MessageChannel、postMessage、setImmediate。而常见的 micro task 有 MutationObsever 和 Promise.then

> Vue.$nextTick 使用宏任务和微任务随版本做过多次变化，并针对浏览器版本最适配，优先支持promise.then

[源码分析](https://libin1991.github.io/2017/10/21/
%E9%9D%A2%E8%AF%95%E4%B9%8BVue-nextTick%E5%8E%9F%E7%90%86/)

> Vue的nextTick主动使用在,假设你更新了data内的数据,数据显示在dom内,你想在数据更新后,对更新过的dom进行其他操作,但是Vue不支持
> 因为Vue会将所有变化放置队列中,而不是变化立刻更新,所以,你无法针对更新的dom进行操作,所有你需要nextTick,传入你想在dom更新后,对dom的操作
> Vue会将dom更新完成后,执行你的操作.  

Vue的nextTickVue在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

[Vue nextTick官网说明](https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97)

## 延伸到macroTask和microTask
> [宏、微任务介绍]("../../../JS/macrotask和microtask.md")


> 
## slot
> <slot> 元素作为组件模板之中的内容分发插槽。<slot> 元素自身将被替换。
> 具有name 属性

tips ：
1.  父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。
> 所以slot内可以访问子作用域的变量
2. 具名插槽:通过name设置多个插槽的名称，可以实现多个插槽
3. 后备内容:为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。我们可以将它放在 <slot> 标签内：
``` javascript
<slot > 默认内容</slot>
```

## 动态、异步组件
### 动态组件
> 
``` javascript
<component v-bind:is="currentTabComponent"></component>
```
### 异步组件
> 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。
> Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。
> Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。
``` javascript
// 工厂函数
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})

// 将异步组件和 webpack 的 code-splitting 功能
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})

//返回一个 Promise，把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：
Vue.Component("AsyncComponent",()=>import("./AsyncComponent.vue"))
```

## 缓存组件keep-alive
> <keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。他是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。
> 
> 当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。
在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发

属性
1. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
2. exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
3. max - 数字。最多可以缓存多少组件实例。
## mixin 混入

[源码解析](https://www.jianshu.com/p/4ab8d255d070)
> 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式,mixin的作用是多个组件可以共享数据和方法

> mixins 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 Vue.extend() 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。


``` javascript
// 局部混入
//./mixin.js
export default {
  methods: {
    foo: function () {
      console.log('foo')
    },
    conflicting: function () {
      console.log('from mixin')
    }
  }
}
import mixin from "./mixin.js"
var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log('bar')
    },
    conflicting: function () {
      console.log('from self')
    }
  }
})

vm.foo() // => "foo"
vm.bar() // => "bar"
vm.conflicting() // => "from self"
// 注意：Vue.extend() 也使用同样的策略进行合并


// 全局混入
// 一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})
new Vue({
  myOption: 'hello!'
})
// => "hello!"
```


选项合并
1. 数据对象（data）在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。
2. 同名钩子函数（created,mounted...）将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
3. 值为对象的选项（methods, components 和 directives）将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。
4. 自定义策略合并
> 新增的选项(如myOption) 定义合并策略
``` javascript
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  if (!toVal) return fromVal
  if (!fromVal) return toVal
  return fromVal + toVal
}
```

> 如果需要判断data里面的取舍再添加策略就行.如果两个参数的选取策略相同, 可使用如下方法:
``` javascript
var strategies = Vue.config.optionMergeStrategies
strategies.data = strategies.method
```